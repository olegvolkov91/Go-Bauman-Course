## Каналы в Go
***
### Каналы - средство для коммуникации между горутинами.
* Каналы можно рассматривать как соединительные трубы, через которые горутины между собой общаются (аналогично тому,
как вода течет по трубам, данные передаются через каналы)
* Канал является реферальным объектом с zeroValue - <nil>.
* Рекомендуется создавать каналы используя функцию make
* Канал может состоять из указателей

```
 func main() {
   var a chan int // объявляем канал, через который будут передаваться данные типа int
   if a == nil {
      fmt.Println("channel is nil, Let's define it")
      a = make(chan int)
      fmt.Printf("Type of a is %T\n", a)
   }
 }
```
***
### Работа с каналами
* Для отправки данных в канал a (chan int) используем синтаксис
```a <- dataInt```
* Для получения данных из канала используем синактсис ```dataInt := <- a```
* Использование однонаправленных каналов никак не сказывается на производительности, а служит лишь для логического разделения кода 
```
// Можно создать канал только на отправку:
sendChan := make(chan<- int)

// Можно создать канал только на чтение
readChan := make(<-chan int)
```
Каналы итерируемая конструкция, следовательно, читать их можно и следующим образом: 
```
for {
  val, ok := <-ch
  if !ok {
    break
  }
  fmt.Println("Recieved from channel", val)
}
```
Либо можно использовать упрощённую конструкцию:
```
for val := range ch {
  fmt.Println("Recieved from channel:", val)
}
```
***ВАЖНО*** - отправка и получения данных из канала - блокирующая операция!
* Это означает, что если данные отправлены в канал, то выполнение текущей программы останавливается до тех пор, пока с другой
стороны из этого канала кто-то не считает данные.
* Аналогично и в обратную сторону. Если кто-то читает из канала, то выполнение текущей программы (горутины) останавливается до тех пор,
пока кто-то в этот канал не отправит данные.
***
### Закрытие канала
Хорошим принципом считается закрытие канала, если мы знаем, что в него больше не будут ничего записывать.
При получении данных из канала, он возвращает 2 переменные
```
  val, ok := <- myChan
  if !ok {...}
```
Таким образом можно управлять состоянием канала 

***ВАЖНО*** - работая с каналами, не рекомендуется создавать каналы с типом interface{}, так как это убивает читаемость кода и непонятно с чем он работает и для чего он нужен
```
  myChan := make(chan interface{}) 
```
***
## Deadlock в Go
***
### Что такое Deadlock? 
* Deadlock - ситуация, когда кто-то пишет в канал, но никто никогда не прочитает, или когда кто-то читает из канала, при этом в него никто никогда ничего не запишет!

По сути ситуация означает, что для отправляющей стороны отсутствует получатель (с другой стороны никто не ждет данных). И наоборот.

Рассмотрим пример:
```
func main() {
  ch := make(chan int)
  ch <- 10
  // <-ch
}
```
