## Указатели в Go 
***
### Шаг 1. Определение указателя
Указатель - это переменная, которая содержит в качестве значения - адрес, в памяти другой переменной 

* Определим указатель для переменной senseOfLife
```
  var senseOfLife int = 42
  var pointer *int = &senseOfLife 
  // &... - операция взятия адреса в памяти
```
В pointer теперь лежит 0xc0000ac008 похожая конструкция, это место в памяти, где хранится значение int 42

***ВАЖНО*** - дефолтное значение указателя это nil
***
### Шаг 2. Разыменовывание указателя
Воспользуемся ранее созданным указателем на переменную senseOfLife
* Для разыменовывания используется символ asterisk * 
```
  var value int = *pointer
  // *... - операция разыменовывания
```
***
### Шаг 3. Создание указателей на дефолтные значения типов
* Для этого создадим переменную
```
  var defaultValue int
  var zeroPointer *int = &defaultValue
```
### Шаг 3.1 Использование оператора new
* Рассмотрим альтернативный вариант в одну строку
```
  zeroPoint = new(int)
```
***ВАЖНО*** - дефолтное значение типа int это 0

### Шаг 4. Передача указателей в функции
* Создадим переменную и указатель на неё

```
  sample := 41
  pointer := *sample
  increase(pointer) 
  // increase(&sample) // <- альтернативная запись 
  
  func increase(val *int) {
    *val += 1
  }
  fmt.Println(sample) // <- 42 
```
***ВАЖНО*** - работа с поинтерами увеличивает производительность работы со значениями, за счёт того, 
что передаётся не значение, а лишь адрес в памяти за которым хранится какое-то значение
***
## Слайс / Массив / Поинтер и их связь
Массив - это низкоуровневая структура с определённым заранее размером

Слайс - это поинтер на массив, который создан под капотом

```
  arr := [3]int{1,2,3}
  
  update(arr[:])
  
  func update(arr []int) {
    arr[1] = 123
  }
```
***ВАЖНО*** - если требуется работать с массивом в качестве аргумента в функцию, стоит подумать о том, чтобы использовать слайс

***
## Cтруктура / Метод / Поинтер и их связь
Для начала определим простейшую структуру типа User, а также определим метод changeName
```
  type User struct {
    Name string
  }
  
  func (u *User) changeName(name string) {
    u.Name = name
  }
  
  func main() {
    u := User{"Gilbert"}
    u.changeName("Ivan")
    fmt.Println(u.Name) // <- Ivan
  }
```
В данном примере, метод структуры changeName ссылается на саму структуру и позволяет менять её значения, для этого необходимо указывать поинтер
