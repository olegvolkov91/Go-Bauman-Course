## Интерфейсы в Go
***
Интерфейс - это явно декларированый набор сигнатур **ПОВЕДЕНИЙ** (чаще всего в виде набора методов), удовлетворив который, можно считаться типом, который декларирует интерфейс.

Интерфейс отвечает на вопрос - что я **ДОЛЖЕН** уметь делать, чтобы считаться тем **ТИПОМ**, который декларирует интерфейс

Интерфейс описывает **ПАТТЕРН ПОВЕДЕНИЯ**

* Первым делом объявим интерфейс с набором методов, которые мы хотим видеть
```
  // наследование интерфейсов
  type Animal interface {
    Runner()
    Flyer()
  }
  
  type Runner interface {
    Run()
  }
  
  type Flyer interface {
    Fly()
  }
```
* Далее необходимо определить структуру у которой будут методы удовлетворяющие поведению интерфейса 
```
type Pigeon struct{}

func (p *Pigeon) Fly() {}
func (p *Pigeon) Run() {}
```
* После чего создаём структуру и передаём её в функцию, которая принимает в качестве аргумента тип Animal
```
func main() {
  p := &Pigeon{}
  animalizer(p)
}

func animalizer(a Animal) {
  a.Run() // или a.Fly()
}
```

Интерфейсы (с точки зрения ООП) - увеличивают уровень абстракции вашего кода
* За счёт увеличения абстракции - можно решать много сторонних проблем связанных с поддержкой, пониманием и реюзабельностью кода


* С другой стороны добавление интерфейсов не решает проблему уменьшения абстрактности

***ВАЖНО*** - интерфейс сам по себе не референсный тип, отсюда вытекает следующее,
при работе с обычным методом, компилятор может самостоятельно взять референс на экземпляр,
однако когда мы пытаемся сделать это через интерфейс, то компилятор в принципе не видит никаких ссылок

