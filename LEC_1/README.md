***Важно*** - .json не гарантирует соблюдения упорядоченности при выдаче ключей!

### Шаг 1 Десериализация 

### Шаг 1.1 Как читают файл .json
* Для начала надо создать файловый дексриптор
```
    jsonFile, err := os.Open("users.json")
``` 
* Сразу же обрабатываем ошибки!
```
    if err != nil {...}
```
* Не забываем закрывать файл после прочтения
```
    defer jsonFile.Close()
```
* Затем нам нужно из файл-дескриптора забрать данные и куда-то их поместить!
```
    json.Unmarshall(byteArr, &куда_записываем)
```
### Шаг 2. Теперь более конкретно
В Go существует 2 способа работы с .json файлами это:
* структуризованая сериализация/десериализация
* не структуризованная сериализация/десериализация

### Шаг 2.1 Cтруктуризация
***Сериализация*** - процесс конвертации объектов в последовательность байтов

***Десериализация*** - процесс конвертации последовательности байтов в объекты

Идея структурированой сериализации/десериализации состоит в том, чтобы общаться с JSON напрямую,
через стыковку полей.

Для того, чтобы настроить стыковку полей нужно:
* Определить необходимые уровни объектности в JSON (в нашем случае их 5)
* Для каждого уровня объектности подготовить свою структуру, учитывающую набор полей объекта
```
    type Person struct {
        Name string `json:"name"`
        Age  int    `json:"age"`
    }
```
* Остаётся только считать с файла и поместить его в экземпляр!

### Шаг 2.2 Неструктуризованый подход
В этом подходе читаемость кода стремится к нулю, но его можно использовать на этапе отладки, чтобы быстро посмотреть,
что находится в json.
```
    jsonFile, err := os.Open("path_to_file")
    if err != nil {...}
    
    info, err := io.ReadAll(jsonFile)
    if err != nil {...}
    
    var data map[string]interface{} // <-- отсутствие структуры ведёт к нулевому пониманию
    if err := json.Unmarshal(info, &data); err != nil {...}
    fmt.Println(data)
```

### Шаг 3. Сериализация
Сериализация всегда имеет структурированый подход
* Для сериализации данных испольуется json.Marshal, который возвращает ошибку 
и перегоняет данные в последовательность байтов

* Также его можно отформатировать используя соответствующий метод json.MarshalIndent, который принимает значение
для форматирования, префикс и отступ, а также возвращает ошибку 

* После чего полученные данные можно куда-то записать 
```
    data, err := json.Marshal(u)
    if err != nil {...}
    
    if err := os.WriteFile("output.json", bytesArr, 0664); err != nil {...}
    fmt.Println("Saved")
```

***ВАЖНО:***  :0664/0666 - это права доступа к файлу (в нашем случае это ```rw``)